import { deepStrictEqual } from "node:assert";
import { describe, it, mock } from "node:test";
import { err, ok } from "@aku11i/phantom-shared";

const listWorktreesMock = mock.fn();

mock.module("./list.ts", {
  namedExports: {
    listWorktrees: listWorktreesMock,
  },
});

const { validateWorktreeExists, validateWorktreeDoesNotExist } = await import(
  "./validate.ts"
);
const { isOk, isErr } = await import("@aku11i/phantom-shared");

describe("validateWorktreeExists", () => {
  const resetMocks = () => {
    listWorktreesMock.mock.resetCalls();
  };

  it("should return ok when worktree is registered", async () => {
    resetMocks();
    listWorktreesMock.mock.mockImplementation(() =>
      Promise.resolve(
        ok({
          worktrees: [
            {
              name: "my-feature",
              path: "/test/repo/.git/phantom/worktrees/my-feature",
              branch: "my-feature",
              isClean: true,
            },
          ],
        }),
      ),
    );

    const result = await validateWorktreeExists(
      "/test/repo",
      "/test/repo/.git/phantom/worktrees",
      "my-feature",
    );

    deepStrictEqual(isOk(result), true);
    deepStrictEqual(result.value, {
      path: "/test/repo/.git/phantom/worktrees/my-feature",
    });
  });

  it("should return err when worktree is not registered", async () => {
    resetMocks();
    listWorktreesMock.mock.mockImplementation(() =>
      Promise.resolve(ok({ worktrees: [] })),
    );

    const result = await validateWorktreeExists(
      "/test/repo",
      "/test/repo/.git/phantom/worktrees",
      "non-existent",
    );

    deepStrictEqual(isErr(result), true);
    deepStrictEqual(result.error.message, "Worktree 'non-existent' not found");
  });

  it("should return err when worktree listing fails", async () => {
    resetMocks();
    listWorktreesMock.mock.mockImplementation(() =>
      Promise.resolve(err(new Error("list failed"))),
    );

    const result = await validateWorktreeExists(
      "/test/repo",
      "/test/repo/.git/phantom/worktrees",
      "any",
    );

    deepStrictEqual(isErr(result), true);
    deepStrictEqual(result.error.message, "Worktree 'any' not found");
  });
});

describe("validateWorktreeDoesNotExist", () => {
  const resetMocks = () => {
    listWorktreesMock.mock.resetCalls();
  };

  it("should return ok when worktree is not registered", async () => {
    resetMocks();
    listWorktreesMock.mock.mockImplementation(() =>
      Promise.resolve(ok({ worktrees: [] })),
    );

    const result = await validateWorktreeDoesNotExist(
      "/test/repo",
      "/test/repo/.git/phantom/worktrees",
      "new-feature",
    );

    deepStrictEqual(isOk(result), true);
    deepStrictEqual(result.value, undefined);
  });

  it("should return err when worktree is already registered", async () => {
    resetMocks();
    listWorktreesMock.mock.mockImplementation(() =>
      Promise.resolve(
        ok({
          worktrees: [
            {
              name: "existing-feature",
              path: "/test/repo/.git/phantom/worktrees/existing-feature",
              branch: "existing-feature",
              isClean: true,
            },
          ],
        }),
      ),
    );

    const result = await validateWorktreeDoesNotExist(
      "/test/repo",
      "/test/repo/.git/phantom/worktrees",
      "existing-feature",
    );

    deepStrictEqual(isErr(result), true);
    deepStrictEqual(
      result.error.message,
      "Worktree 'existing-feature' already exists",
    );
  });

  it("should return err when listing fails", async () => {
    resetMocks();
    listWorktreesMock.mock.mockImplementation(() =>
      Promise.resolve(err(new Error("list failed"))),
    );

    const result = await validateWorktreeDoesNotExist(
      "/test/repo",
      "/test/repo/.git/phantom/worktrees",
      "new-feature",
    );

    deepStrictEqual(isErr(result), true);
    deepStrictEqual(
      result.error.message,
      "Worktree 'new-feature' already exists",
    );
  });
});
